`include "PACKAGE.types.colData.sv"
`include "PACKAGE.constants.colData.sv"
//*******************************************************************************************
//*******************************************************************************************
//***
//***	Module Name: colData_2MHzClkGen
//***	Description: Derives the 2MHz Clk from the 64MHz Clk
//***
//*******************************************************************************************
//*******************************************************************************************
module	colData_2MHzClkGen	(	output	logic						Clk_2MHz_Sys,			//	The 2MHz Clock generated by this module
															input		logic						Clk_64MHz_Sys,		//	The Master 64MHz System Clock
															input		logic						edgeNow,					//	A signal issued by the FastCommand logic
																																				//		that indicates when the positive edge of
																																				//		the 2MHz Clock must be
															input 	logic 					syncNow,					//	A signal issued by the FastCommand Logic
																																				//		that indicates that on the next rising
																																				//		edge of the 2MHz Clock the timeStamp
																																				//		must be zeroed
															output 	logic			[7:0]	timeStamp,				//	Eight bit time stamp for the system
															input 	logic						DLL_Reset,				//	Reset issued by the Reset Module
															input 	logic 					CORE_Run
														);

//*******************************************************************************************
//*******************************************************************************************
//***
//***	Variables
//***
//*******************************************************************************************
//*******************************************************************************************
	logic 	[4:0]		ClkCount;
	logic 					almostClkOut;
	logic 					comb1;
	logic 					comb2;
	logic 					comb3;
	logic 					resetTimeStamp;

//We start by assuming that edgeNow comes out at the falling edge
//of the 64MHz Clock and exists for 1 complete 64MHz Clock period.

//Here is where we use the edgeNow (on the "next" positive edge of the Clk)
//First, we reset the ClkCount according to the DLL Reset of the reset module.  Second, if we see
//the edgeNow, then ClkCount must be set to a 1 since edgeNow is delayed by a Clock cycle by
//the FastCommand module.
//All this will mean that in future cycles on the positive edge of the Clk, ClkCount will advance
//from 5'b0_0000 (0) to 5'b1_1111 (31) over the course of a complete 2MHz Clk period
//(for all subsequent 2MHz Clk cycles)
	always_ff @(	posedge Clk_64MHz_Sys	or negedge DLL_Reset	)
		if( DLL_Reset == ZERO )
			ClkCount 	<=	5'b0_0000;
		else if ( edgeNow == ONE	)
			ClkCount 	<=	5'b0_0001;
		else
			ClkCount	<=	ClkCount + 5'b0_0001;

//We want Clk_2MHz_Sys to be a direct consequence of Clk_64MHz_Sys.  Therefore, we do not
//want combinatorial logic to form Clk_2MHz_Sys from the states of ClkCount.  We want
//combinatorial logic to form a signal that gets latched on the falling edge of Clk_64MHz_Sys
//as almostClkOut and then that signal gets latched by the next rising edge of Clk_64MHz_Sys as
//Clk_2MHz_Sys.  Therefore, the combinatorial logic function must be a
//	1	if 	ClkCount 	=	5'b1_1111 			0	if 	ClkCount 	= 	5'b0_1111
//										5'b0_0000 													5'b1_0000
//										5'b0_0001 													5'b1_0001
//										5'b0_0010 													5'b1_0010
//										5'b0_0011 													5'b1_0011
//										5'b0_0100 													5'b1_0100
//										5'b0_0101 													5'b1_0101
//										5'b0_0110 													5'b1_0110
//										5'b0_0111 													5'b1_0111
//										5'b0_1000 													5'b1_1000
//										5'b0_1001 													5'b1_1001
//										5'b0_1010 													5'b1_1010
//										5'b0_1011 													5'b1_1011
//										5'b0_1100 													5'b1_1100
//										5'b0_1101 													5'b1_1101
//										5'b0_1110 													5'b1_1110
//	That is to say that the combinatorial logic must be a 1 if ClkCount[4]=1
//	and ClkCount[3] && ClkCount[2] && ClkCount[1] && ClkCount[0] = 1
//	OR ClkCount[4] = 0
//	and ClkCount[3]' || ClkCount[2]' || ClkCount[1]' || ClkCount[0]' = 1
//
//	In other words, we are anticipating that the rising edge of Clk_2MHz_Sys will
//	happen on the rising edge of Clk_64MHz_Sys that is between the ClkCount states
//	5'b1_1111 and 5'b_0000 and that the falling edge of Clk_2MHz_Sys will happen
//	on the rising edge of Clk_64MHz_Sys that is between the ClkCount states
//	5'b0_1111 and 5'b1_0000.

	always_comb
		begin
			comb1	=	ClkCount[3] && ClkCount[2] && ClkCount[1] && ClkCount[0];
			comb2	=	(ClkCount[4] && comb1) || (!ClkCount[4] && !comb1);
			comb3	=	comb2	&&	CORE_Run;
		end

	always @(	negedge	Clk_64MHz_Sys	)
		almostClkOut	<=	comb3;

	always @(	posedge	Clk_64MHz_Sys	)
		Clk_2MHz_Sys	<=	almostClkOut;

//Now that we have a 2MHz Clock, the first thing that we need to do is use it to create
//the timeStamp.	The timeStamp will be reset by a command (syncNow) from the FastCommand.
//This command will exist from one falling edge of the 64MHz Clk to the next but it will
//not be any random 64MHz Clk period.  It will only be during ClkCount 7, 15, 23 or 31.
//Then this signal should be held high through the positive edge of the 2MHz Clk.
//Therefore, we let the FastCommand set a signal and we let that signal be reset by
//ClkCount = 4.  This keeps the resetting away from the positive edge.

	assign 	resetTimeStamp	=	(DLL_Reset == ZERO) || (syncNow == ONE);

	always @( posedge Clk_2MHz_Sys or posedge resetTimeStamp )
		if( resetTimeStamp == ONE )
			timeStamp	<=	8'b0000_0000;
		else
			timeStamp <=	timeStamp + 8'b0000_0001;

endmodule
